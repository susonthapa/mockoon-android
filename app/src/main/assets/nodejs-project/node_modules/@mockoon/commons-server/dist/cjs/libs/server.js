"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockoonServer = void 0;
const commons_1 = require("@mockoon/commons");
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const events_1 = require("events");
const express_1 = __importDefault(require("express"));
const fs_1 = require("fs");
const http_1 = require("http");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const https_1 = require("https");
const killable_1 = __importDefault(require("killable"));
const mime_types_1 = require("mime-types");
const path_1 = require("path");
const qs_1 = require("qs");
const xml_js_1 = require("xml-js");
const ssl_constants_1 = require("../constants/ssl.constants");
const en_1 = require("../i18n/en");
const response_rules_interpreter_1 = require("./response-rules-interpreter");
const template_parser_1 = require("./template-parser");
const utils_1 = require("./utils");
/**
 * Create a server instance from an Environment object.
 *
 * Extends EventEmitter.
 */
class MockoonServer extends events_1.EventEmitter {
    constructor(environment, options = {}) {
        super();
        this.environment = environment;
        this.options = options;
        /**
         * ### Middleware ###
         * Emit the SERVER_ENTERING_REQUEST event
         *
         * @param request
         * @param response
         * @param next
         */
        this.emitEvent = (request, response, next) => {
            this.emit('entering-request');
            next();
        };
        /**
         * ### Middleware ###
         * Add global latency to the mock server
         *
         * @param request
         * @param response
         * @param next
         */
        this.delayResponse = (request, response, next) => {
            this.refreshEnvironment();
            setTimeout(next, this.environment.latency);
        };
        /**
         * ### Middleware ###
         * Parse entering request body
         *
         * @param request
         * @param response
         * @param next
         */
        this.parseBody = (request, response, next) => {
            // Parse body as a raw string and JSON/form if applicable
            const requestContentType = request.header('Content-Type');
            const rawBody = [];
            request.on('data', (chunk) => {
                rawBody.push(Buffer.from(chunk, 'binary'));
            });
            request.on('end', () => {
                request.rawBody = Buffer.concat(rawBody);
                request.body = request.rawBody.toString('utf8');
                try {
                    if (requestContentType) {
                        if (requestContentType.includes('application/json')) {
                            request.parsedBody = JSON.parse(request.body);
                        }
                        else if (requestContentType.includes('application/x-www-form-urlencoded')) {
                            request.parsedBody = qs_1.parse(request.body, {
                                depth: 10
                            });
                        }
                        else if (requestContentType.includes('application/xml') ||
                            requestContentType.includes('text/xml')) {
                            request.parsedBody = xml_js_1.xml2js(request.body, {
                                compact: true
                            });
                        }
                    }
                }
                catch (error) {
                    this.emit('error', commons_1.ServerErrorCodes.REQUEST_BODY_PARSE, error);
                }
                next();
            });
        };
        /**
         * ### Middleware ###
         * Emit an event when response emit the 'close' event
         *
         * @param request
         * @param response
         * @param next
         */
        this.logRequest = (request, response, next) => {
            response.on('close', () => {
                this.emit('transaction-complete', utils_1.CreateTransaction(request, response));
            });
            next();
        };
        /**
         * ### Middleware ###
         * Add environment headers & proxy headers to the response
         *
         * @param request
         * @param response
         * @param next
         */
        this.setResponseHeaders = (request, response, next) => {
            this.setHeaders(this.environment.headers, response, request);
            next();
        };
        /**
         * ### Middleware ###
         * Catch all error handler
         * http://expressjs.com/en/guide/error-handling.html#catching-errors
         *
         * @param server - server on which to log the response
         */
        this.errorHandler = (error, request, response, next) => {
            this.sendError(response, error, 500);
        };
    }
    /**
     * Start a server
     */
    start() {
        const server = express_1.default();
        server.disable('x-powered-by');
        server.disable('etag');
        // create https or http server instance
        if (this.environment.https) {
            this.serverInstance = https_1.createServer(ssl_constants_1.DefaultSSLConfig, server);
        }
        else {
            this.serverInstance = http_1.createServer(server);
        }
        // make serverInstance killable
        this.serverInstance = killable_1.default(this.serverInstance);
        // set timeout long enough to allow long latencies
        this.serverInstance.setTimeout(3600000);
        // handle server errors
        this.serverInstance.on('error', (error) => {
            let errorCode;
            switch (error.code) {
                case 'EADDRINUSE':
                    errorCode = commons_1.ServerErrorCodes.PORT_ALREADY_USED;
                    break;
                case 'EACCES':
                    errorCode = commons_1.ServerErrorCodes.PORT_INVALID;
                    break;
                case 'EADDRNOTAVAIL':
                    errorCode = commons_1.ServerErrorCodes.HOSTNAME_UNAVAILABLE;
                    break;
                case 'ENOTFOUND':
                    errorCode = commons_1.ServerErrorCodes.HOSTNAME_UNKNOWN;
                    break;
                default:
                    errorCode = commons_1.ServerErrorCodes.UNKNOWN_SERVER_ERROR;
            }
            this.emit('error', errorCode, error);
        });
        this.serverInstance.listen(this.environment.port, this.environment.hostname, () => {
            this.emit('started');
        });
        server.use(this.emitEvent);
        server.use(this.delayResponse);
        server.use(this.deduplicateSlashes);
        server.use(cookie_parser_1.default());
        server.use(this.parseBody);
        server.use(this.logRequest);
        server.use(this.setResponseHeaders);
        this.setRoutes(server);
        this.setCors(server);
        this.enableProxy(server);
        server.use(this.errorHandler);
    }
    /**
     * Kill the server
     */
    stop() {
        if (this.serverInstance) {
            this.serverInstance.kill(() => {
                this.emit('stopped');
            });
        }
    }
    /**
     * ### Middleware ###
     * Remove duplicate slashes in entering call paths
     *
     * @param request
     * @param response
     * @param next
     */
    deduplicateSlashes(request, response, next) {
        request.url = request.url.replace(/\/{2,}/g, '/');
        next();
    }
    /**
     * Generate an environment routes and attach to running server
     *
     * @param server - server on which attach routes
     */
    setRoutes(server) {
        this.environment.routes.forEach((declaredRoute) => {
            // only launch non duplicated routes, or ignore if none.
            if (declaredRoute.enabled) {
                try {
                    let routePath = `/${this.environment.endpointPrefix}/${declaredRoute.endpoint.replace(/ /g, '%20')}`;
                    routePath = routePath.replace(/\/{2,}/g, '/');
                    let requestNumber = 1;
                    // create route
                    server[declaredRoute.method](routePath, (request, response) => {
                        // refresh environment data to get route changes that do not require a restart (headers, body, etc)
                        this.refreshEnvironment();
                        const currentRoute = this.getRefreshedRoute(declaredRoute);
                        if (!currentRoute) {
                            this.sendError(response, en_1.Texts.EN.MESSAGES.ROUTE_NO_LONGER_EXISTS, 404);
                            return;
                        }
                        const enabledRouteResponse = new response_rules_interpreter_1.ResponseRulesInterpreter(currentRoute.responses, request, currentRoute.randomResponse, currentRoute.sequentialResponse).chooseResponse(requestNumber);
                        requestNumber += 1;
                        // save route and response UUIDs for logs (only in desktop app)
                        if (declaredRoute.uuid && enabledRouteResponse.uuid) {
                            response.routeUUID = declaredRoute.uuid;
                            response.routeResponseUUID = enabledRouteResponse.uuid;
                        }
                        // add route latency if any
                        setTimeout(() => {
                            const contentType = commons_1.GetRouteResponseContentType(this.environment, enabledRouteResponse);
                            const routeContentType = commons_1.GetContentType(enabledRouteResponse.headers);
                            // set http code
                            response.status(enabledRouteResponse.statusCode);
                            this.setHeaders(enabledRouteResponse.headers, response, request);
                            // send the file
                            if (enabledRouteResponse.filePath) {
                                this.sendFile(enabledRouteResponse, routeContentType, request, response);
                            }
                            else {
                                if (contentType.includes('application/json')) {
                                    response.set('Content-Type', 'application/json');
                                }
                                this.serveBody(enabledRouteResponse, request, response);
                            }
                        }, enabledRouteResponse.latency);
                    });
                }
                catch (error) {
                    let errorCode = commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR;
                    // if invalid regex defined
                    if (error.message.indexOf('Invalid regular expression') > -1) {
                        errorCode = commons_1.ServerErrorCodes.ROUTE_CREATION_ERROR_REGEX;
                    }
                    this.emit('error', errorCode, error);
                }
            }
        });
    }
    /**
     * Parse the body templating and send it as the response body
     *
     * @param routeResponse
     * @param request
     * @param response
     */
    serveBody(routeResponse, request, response) {
        try {
            let body = routeResponse.body;
            if (!routeResponse.disableTemplating) {
                body = template_parser_1.TemplateParser(body || '', request, this.environment);
            }
            response.body = body;
            response.send(body);
        }
        catch (error) {
            this.emit('error', commons_1.ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${en_1.Texts.EN.MESSAGES.ROUTE_SERVING_ERROR}${error.message}`);
        }
    }
    /**
     * Send a file as response body.
     * Revert to sendBody if file is not found.
     *
     * @param routeResponse
     * @param routeContentType
     * @param request
     * @param response
     */
    sendFile(routeResponse, routeContentType, request, response) {
        try {
            const filePath = template_parser_1.TemplateParser(routeResponse.filePath.replace(/\\/g, '/'), request, this.environment);
            let processedFilePath;
            if (!this.options.environmentDirectory) {
                processedFilePath = filePath;
            }
            else if (path_1.isAbsolute(filePath)) {
                processedFilePath = filePath;
            }
            else {
                processedFilePath = path_1.resolve(this.options.environmentDirectory, filePath);
            }
            fs_1.readFile(processedFilePath, (readError, data) => {
                try {
                    if (readError && !routeResponse.fallbackTo404) {
                        throw readError;
                    }
                    else if (readError && routeResponse.fallbackTo404) {
                        response.status(404);
                        this.serveBody(routeResponse, request, response);
                        return;
                    }
                    const fileMimeType = mime_types_1.lookup(filePath) || '';
                    // set content-type to route response's one or the detected mime type if none
                    if (!routeContentType) {
                        response.set('Content-Type', fileMimeType);
                    }
                    if (!routeResponse.sendFileAsBody) {
                        response.set('Content-Disposition', `attachment; filename="${path_1.basename(filePath)}"`);
                    }
                    // parse templating for a limited list of mime types
                    if (commons_1.MimeTypesWithTemplating.indexOf(fileMimeType) > -1 &&
                        !routeResponse.disableTemplating) {
                        const fileContent = template_parser_1.TemplateParser(data.toString(), request, this.environment);
                        response.body = fileContent;
                        response.send(fileContent);
                    }
                    else {
                        response.body = commons_1.BINARY_BODY;
                        response.send(data);
                    }
                }
                catch (error) {
                    this.emit('error', commons_1.ServerErrorCodes.ROUTE_FILE_SERVING_ERROR, error);
                    this.sendError(response, `${en_1.Texts.EN.MESSAGES.ROUTE_FILE_SERVING_ERROR}${error.message}`);
                }
            });
        }
        catch (error) {
            this.emit('error', commons_1.ServerErrorCodes.ROUTE_SERVING_ERROR, error);
            this.sendError(response, `${en_1.Texts.EN.MESSAGES.ROUTE_SERVING_ERROR}${error.message}`);
        }
    }
    /**
     * Always answer with status 200 to CORS pre flight OPTIONS requests if option activated.
     * /!\ Must be called after the routes creation otherwise it will intercept all user defined OPTIONS routes.
     *
     * @param server - express instance
     */
    setCors(server) {
        if (this.environment.cors) {
            server.options('/*', (req, res) => {
                this.refreshEnvironment();
                // override default CORS headers with environment's headers
                this.setHeaders([...commons_1.CORSHeaders, ...this.environment.headers], res, req);
                res.status(200).end();
            });
        }
    }
    /**
     * Add catch-all proxy if enabled.
     * Restream the body to the proxied API because it already has been
     * intercepted by the body parser.
     *
     * @param server - server on which to launch the proxy
     */
    enableProxy(server) {
        if (this.environment.proxyMode &&
            this.environment.proxyHost &&
            commons_1.IsValidURL(this.environment.proxyHost)) {
            this.emit('creating-proxy');
            server.use('*', http_proxy_middleware_1.createProxyMiddleware({
                target: this.environment.proxyHost,
                secure: false,
                changeOrigin: true,
                logProvider: this.options.logProvider,
                ssl: Object.assign(Object.assign({}, ssl_constants_1.DefaultSSLConfig), { agent: false }),
                onProxyReq: (proxyReq, request, response) => {
                    this.refreshEnvironment();
                    request.proxied = true;
                    this.setHeaders(this.environment.proxyReqHeaders, proxyReq, request);
                    if (this.environment.proxyRemovePrefix === true &&
                        this.environment.endpointPrefix.length > 0) {
                        const regExp = new RegExp(`^/${this.environment.endpointPrefix}`);
                        proxyReq.path = proxyReq.path.replace(regExp, '');
                    }
                    // re-stream the body (intercepted by body parser method)
                    if (request.rawBody) {
                        proxyReq.write(request.rawBody);
                    }
                },
                onProxyRes: (proxyRes, request, response) => {
                    this.refreshEnvironment();
                    const buffers = [];
                    proxyRes.on('data', (chunk) => {
                        buffers.push(chunk);
                    });
                    proxyRes.on('end', () => {
                        response.body = Buffer.concat(buffers);
                    });
                    this.setHeaders(this.environment.proxyResHeaders, proxyRes, request);
                },
                onError: (error, request, response) => {
                    this.emit('error', commons_1.ServerErrorCodes.PROXY_ERROR, error);
                    this.sendError(response, `${en_1.Texts.EN.MESSAGES.PROXY_ERROR}${this.environment.proxyHost}${request.url}: ${error}`, 504);
                }
            }));
        }
    }
    /**
     * Set the provided headers on the target. Use different headers accessors
     * depending on the type of target:
     * express.Response/http.OutgoingMessage/http.IncomingMessage
     * Use the source in the template parsing of each header value.
     *
     * @param headers
     * @param target
     * @param request
     */
    setHeaders(headers, target, request) {
        headers.forEach((header) => {
            const isSetCookie = header.key.toLowerCase() === 'set-cookie';
            const parsedHeaderValue = this.parseHeader(header, request);
            if (parsedHeaderValue === null) {
                return;
            }
            if (target.set) {
                // for express.Response
                if (isSetCookie) {
                    target.append(header.key, parsedHeaderValue);
                }
                else {
                    target.set(header.key, parsedHeaderValue);
                }
            }
            else if (target.setHeader) {
                // for proxy http.OutgoingMessage | ClientRequest
                target.setHeader(header.key, parsedHeaderValue);
            }
            else {
                // for http.IncomingMessage
                if (isSetCookie) {
                    target.headers[header.key] = this.appendHeaderValue(target.headers[header.key], parsedHeaderValue);
                }
                else {
                    target.headers[header.key] = parsedHeaderValue;
                }
            }
        });
    }
    /**
     * If header already has a value, concatenate the values into an array
     *
     * @param currentValue
     * @param newValue
     * @returns
     */
    appendHeaderValue(currentValue, newValue) {
        let headerValue = newValue;
        if (currentValue) {
            headerValue = Array.isArray(currentValue)
                ? currentValue.concat(headerValue)
                : [currentValue, headerValue];
        }
        return headerValue;
    }
    /**
     * Verify a header validity and parse its content, if templating is used
     *
     * @param header
     * @param request
     * @returns
     */
    parseHeader(header, request) {
        let parsedHeaderValue = null;
        if (header.key && header.value && !commons_1.TestHeaderValidity(header.key)) {
            try {
                parsedHeaderValue = template_parser_1.TemplateParser(header.value, request, this.environment);
            }
            catch (error) {
                const errorMessage = en_1.Texts.EN.MESSAGES.HEADER_PARSING_ERROR;
                parsedHeaderValue = errorMessage;
            }
        }
        return parsedHeaderValue;
    }
    /**
     * Send an error with text/plain content type, the provided message and status code.
     * Status is optional. No status will default to the one defined by the user, allowing for maximum customization.
     *
     * @param response
     * @param errorMessage
     * @param status
     */
    sendError(response, errorMessage, status) {
        response.set('Content-Type', 'text/plain');
        response.body = errorMessage;
        if (status !== undefined) {
            response.status(status);
        }
        response.send(errorMessage);
    }
    /**
     * Request an updated environment to allow
     * modification of some parameters without a restart (latency, headers, etc)
     */
    refreshEnvironment() {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            const updatedEnvironment = this.options.refreshEnvironmentFunction(this.environment.uuid);
            if (updatedEnvironment) {
                this.environment = updatedEnvironment;
            }
        }
    }
    /**
     * Request an updated route to allow
     * modification of some parameters without a restart (latency, headers, etc)
     * This only makes sense if the refreshEnvironmentFunction has been provided.
     *
     * @param routeUUID
     */
    getRefreshedRoute(currentRoute) {
        if (this.options.refreshEnvironmentFunction && this.environment.uuid) {
            return this.environment.routes.find((route) => route.uuid === currentRoute.uuid);
        }
        return currentRoute;
    }
}
exports.MockoonServer = MockoonServer;
//# sourceMappingURL=server.js.map