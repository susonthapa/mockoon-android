import { Environment, MockoonServerOptions, ServerEvents } from '@mockoon/commons';
import TypedEmitter from 'typed-emitter';
declare const MockoonServer_base: new () => TypedEmitter<ServerEvents>;
/**
 * Create a server instance from an Environment object.
 *
 * Extends EventEmitter.
 */
export declare class MockoonServer extends MockoonServer_base {
    private environment;
    private options;
    private serverInstance;
    constructor(environment: Environment, options?: MockoonServerOptions);
    /**
     * Start a server
     */
    start(): void;
    /**
     * Kill the server
     */
    stop(): void;
    /**
     * ### Middleware ###
     * Emit the SERVER_ENTERING_REQUEST event
     *
     * @param request
     * @param response
     * @param next
     */
    private emitEvent;
    /**
     * ### Middleware ###
     * Add global latency to the mock server
     *
     * @param request
     * @param response
     * @param next
     */
    private delayResponse;
    /**
     * ### Middleware ###
     * Remove duplicate slashes in entering call paths
     *
     * @param request
     * @param response
     * @param next
     */
    private deduplicateSlashes;
    /**
     * ### Middleware ###
     * Parse entering request body
     *
     * @param request
     * @param response
     * @param next
     */
    private parseBody;
    /**
     * ### Middleware ###
     * Emit an event when response emit the 'close' event
     *
     * @param request
     * @param response
     * @param next
     */
    private logRequest;
    /**
     * ### Middleware ###
     * Add environment headers & proxy headers to the response
     *
     * @param request
     * @param response
     * @param next
     */
    private setResponseHeaders;
    /**
     * Generate an environment routes and attach to running server
     *
     * @param server - server on which attach routes
     */
    private setRoutes;
    /**
     * Parse the body templating and send it as the response body
     *
     * @param routeResponse
     * @param request
     * @param response
     */
    private serveBody;
    /**
     * Send a file as response body.
     * Revert to sendBody if file is not found.
     *
     * @param routeResponse
     * @param routeContentType
     * @param request
     * @param response
     */
    private sendFile;
    /**
     * Always answer with status 200 to CORS pre flight OPTIONS requests if option activated.
     * /!\ Must be called after the routes creation otherwise it will intercept all user defined OPTIONS routes.
     *
     * @param server - express instance
     */
    private setCors;
    /**
     * Add catch-all proxy if enabled.
     * Restream the body to the proxied API because it already has been
     * intercepted by the body parser.
     *
     * @param server - server on which to launch the proxy
     */
    private enableProxy;
    /**
     * ### Middleware ###
     * Catch all error handler
     * http://expressjs.com/en/guide/error-handling.html#catching-errors
     *
     * @param server - server on which to log the response
     */
    private errorHandler;
    /**
     * Set the provided headers on the target. Use different headers accessors
     * depending on the type of target:
     * express.Response/http.OutgoingMessage/http.IncomingMessage
     * Use the source in the template parsing of each header value.
     *
     * @param headers
     * @param target
     * @param request
     */
    private setHeaders;
    /**
     * If header already has a value, concatenate the values into an array
     *
     * @param currentValue
     * @param newValue
     * @returns
     */
    private appendHeaderValue;
    /**
     * Verify a header validity and parse its content, if templating is used
     *
     * @param header
     * @param request
     * @returns
     */
    private parseHeader;
    /**
     * Send an error with text/plain content type, the provided message and status code.
     * Status is optional. No status will default to the one defined by the user, allowing for maximum customization.
     *
     * @param response
     * @param errorMessage
     * @param status
     */
    private sendError;
    /**
     * Request an updated environment to allow
     * modification of some parameters without a restart (latency, headers, etc)
     */
    private refreshEnvironment;
    /**
     * Request an updated route to allow
     * modification of some parameters without a restart (latency, headers, etc)
     * This only makes sense if the refreshEnvironmentFunction has been provided.
     *
     * @param routeUUID
     */
    private getRefreshedRoute;
}
export {};
