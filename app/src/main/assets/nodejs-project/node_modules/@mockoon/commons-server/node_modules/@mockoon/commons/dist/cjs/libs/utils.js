"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestHeaderValidity = exports.IsValidURL = exports.GetRouteResponseContentType = exports.GetContentType = void 0;
/**
 * Extract the content-type from an array of headers
 *
 * @param headers
 */
const GetContentType = (headers) => {
    const contentTypeHeader = headers.find((header) => header.key.toLowerCase() === 'content-type');
    if (contentTypeHeader) {
        return contentTypeHeader.value;
    }
    return null;
};
exports.GetContentType = GetContentType;
/**
 * Return a route response's content-type.
 * Environment's content-type is overridden by route's content-type
 *
 * @param environment
 * @param routeResponse
 */
const GetRouteResponseContentType = (environment, routeResponse) => {
    const routeResponseContentType = exports.GetContentType(routeResponse.headers);
    const environmentContentType = exports.GetContentType(environment.headers);
    return routeResponseContentType || environmentContentType || '';
};
exports.GetRouteResponseContentType = GetRouteResponseContentType;
/**
 * Test if URL is valid
 *
 * @param URL
 */
const IsValidURL = (address) => {
    try {
        const myURL = new URL(address);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.IsValidURL = IsValidURL;
/**
 * Test a header validity
 *
 * @param headerName
 */
const TestHeaderValidity = (headerName) => {
    if (headerName &&
        headerName.match(/[^A-Za-z0-9\-\!\#\$\%\&\'\*\+\.\^\_\`\|\~]/g)) {
        return true;
    }
    return false;
};
exports.TestHeaderValidity = TestHeaderValidity;
//# sourceMappingURL=utils.js.map