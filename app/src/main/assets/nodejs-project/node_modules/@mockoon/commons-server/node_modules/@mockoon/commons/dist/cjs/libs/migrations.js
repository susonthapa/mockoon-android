"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighestMigrationId = exports.Migrations = void 0;
const uuid_1 = require("uuid");
/**
 * List of migration functions.
 *
 * Will determine import compatibility:
 * lastMigration < HighestMigrationId -> migrate
 * lastMigration > HighestMigrationId -> error
 */
exports.Migrations = [
    // v0.4.0beta
    {
        id: 1,
        migrationFunction: (environment) => {
            // proxy settings
            if (!environment.proxyMode) {
                environment.proxyMode = false;
            }
            if (!environment.proxyHost) {
                environment.proxyHost = '';
            }
            if (!environment.https) {
                environment.https = false;
            }
        }
    },
    // 1.0.0
    {
        id: 2,
        migrationFunction: (environment) => {
            if (!environment.cors) {
                environment.cors = true;
            }
            environment.routes.forEach((route) => {
                // add uuid
                if (!route.uuid) {
                    route.uuid = uuid_1.v4();
                }
                if (route['customHeaders']) {
                    // find content type header
                    const ContentTypeHeader = route['customHeaders'].find((customHeader) => customHeader.key === 'Content-Type');
                    // add custom header only if no content type
                    if (!ContentTypeHeader) {
                        route['customHeaders'].unshift({
                            uuid: uuid_1.v4(),
                            key: 'Content-Type',
                            value: route['contentType']
                        });
                    }
                    // delete old content type
                    delete route['contentType'];
                }
            });
        }
    },
    // 1.2.0
    {
        id: 3,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                // add missing uuid
                if (!route.uuid) {
                    route.uuid = uuid_1.v4();
                }
            });
        }
    },
    // 1.3.0
    {
        id: 4,
        migrationFunction: (environment) => {
            // add new headers property to environments
            if (!environment.headers) {
                environment.headers = [{ uuid: uuid_1.v4(), key: '', value: '' }];
            }
            environment.routes.forEach((route) => {
                // add missing sendAsBody
                if (route.file && route.file.sendAsBody === undefined) {
                    route.file.sendAsBody = false;
                }
                // add missing documentation
                if (route.documentation === undefined) {
                    route.documentation = '';
                }
                // rename customHeaders to headers
                if (route['customHeaders']) {
                    route['headers'] = route['customHeaders'];
                    delete route['customHeaders'];
                }
            });
        }
    },
    // 1.4.0
    {
        id: 5,
        migrationFunction: (environment) => {
            delete environment['duplicates'];
            environment.routes.forEach((route) => {
                // remove file object
                route['filePath'] = route.file ? route.file.path : '';
                route['sendFileAsBody'] = route.file ? route.file.sendAsBody : false;
                delete route.file;
                delete route['duplicates'];
            });
        }
    },
    /**
     * Multiple route responses:
     * Create a responses object in each route and migrate the old route properties in the new route response
     */
    {
        id: 6,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses = [];
                route.responses.push({
                    uuid: uuid_1.v4(),
                    statusCode: route.statusCode,
                    label: '',
                    latency: route.latency,
                    filePath: route.filePath,
                    sendFileAsBody: route.sendFileAsBody,
                    headers: route.headers,
                    body: route.body,
                    rules: []
                });
                delete route.statusCode;
                delete route.latency;
                delete route.filePath;
                delete route.sendFileAsBody;
                delete route.headers;
                delete route.body;
            });
        }
    },
    /**
     * Renew route responses UUID to ensure no uuid were duplicated after v1.5.0
     */
    {
        id: 7,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses.forEach((routeResponse) => {
                    routeResponse.uuid = uuid_1.v4();
                });
            });
        }
    },
    /**
     * Create a "enabled" param
     */
    {
        id: 8,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.enabled = true;
            });
        }
    },
    /**
     * Add route response label
     */
    {
        id: 9,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses.forEach((routeResponse) => {
                    if (!routeResponse.label) {
                        routeResponse.label = '';
                    }
                });
            });
        }
    },
    /**
     * Add proxy request/response headers
     */
    {
        id: 10,
        migrationFunction: (environment) => {
            // add new proxy request/response headers property to environments
            if (!environment.proxyReqHeaders) {
                environment.proxyReqHeaders = [{ key: '', value: '' }];
            }
            if (!environment.proxyResHeaders) {
                environment.proxyResHeaders = [{ key: '', value: '' }];
            }
        }
    },
    /**
     * Add route response's disableTemplating option.
     * Convert statusCode to number
     */
    {
        id: 11,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses.forEach((routeResponse) => {
                    if (routeResponse.disableTemplating === undefined) {
                        routeResponse.disableTemplating = false;
                    }
                    routeResponse.statusCode = parseInt(routeResponse.statusCode, 10);
                });
            });
        }
    },
    /**
     * Add route response rulesOperator
     */
    {
        id: 12,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses.forEach((routeResponse) => {
                    if (routeResponse.rulesOperator === undefined) {
                        routeResponse.rulesOperator = 'OR';
                    }
                });
            });
        }
    },
    /**
     * Add route randomResponse param
     */
    {
        id: 13,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                if (route.randomResponse === undefined) {
                    route.randomResponse = false;
                }
            });
        }
    },
    /**
     * Add route sequentialResponse param
     */
    {
        id: 14,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                if (route.sequentialResponse === undefined) {
                    route.sequentialResponse = false;
                }
            });
        }
    },
    /**
     * Add proxyRemovePrefix param
     */
    {
        id: 15,
        migrationFunction: (environment) => {
            if (environment.proxyRemovePrefix === undefined) {
                environment.proxyRemovePrefix = false;
            }
        }
    },
    /**
     * Add hostname
     */
    {
        id: 16,
        migrationFunction: (environment) => {
            if (!environment.hostname) {
                environment.hostname = '0.0.0.0';
            }
        }
    },
    /**
     * Add route response's fallbackTo404 option.
     */
    {
        id: 17,
        migrationFunction: (environment) => {
            environment.routes.forEach((route) => {
                route.responses.forEach((routeResponse) => {
                    if (routeResponse.fallbackTo404 === undefined) {
                        routeResponse.fallbackTo404 = false;
                    }
                });
            });
        }
    }
];
exports.HighestMigrationId = exports.Migrations[exports.Migrations.length - 1].id;
//# sourceMappingURL=migrations.js.map