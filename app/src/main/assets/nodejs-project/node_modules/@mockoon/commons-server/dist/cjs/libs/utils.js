"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromSafeString = exports.ToBase64 = exports.CreateTransaction = exports.DecompressBody = exports.RandomInt = exports.IsEmpty = void 0;
const handlebars_1 = require("handlebars");
const url_1 = require("url");
const zlib_1 = require("zlib");
/**
 * Transform http headers objects to Mockoon's Header key value object
 *
 * @param object
 */
const TransformHeaders = (headers) => Object.keys(headers).reduce((newHeaders, key) => {
    const headerValue = headers[key];
    let value = '';
    if (headerValue !== undefined) {
        if (Array.isArray(headerValue)) {
            value = headerValue.join(',');
        }
        else {
            value = headerValue.toString();
        }
    }
    newHeaders.push({ key, value });
    return newHeaders;
}, []);
/**
 * Sort by ascending order
 *
 * @param a
 * @param b
 */
const AscSort = (a, b) => {
    if (a.key < b.key) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * Check if an Object or Array is empty
 *
 * @param obj
 */
const IsEmpty = (obj) => [Object, Array].includes((obj || {}).constructor) &&
    !Object.entries(obj || {}).length;
exports.IsEmpty = IsEmpty;
/**
 * Return a random integer
 *
 * @param a
 * @param b
 */
const RandomInt = (a = 1, b = 0) => {
    const lower = Math.ceil(Math.min(a, b));
    const upper = Math.floor(Math.max(a, b));
    return Math.floor(lower + Math.random() * (upper - lower + 1));
};
exports.RandomInt = RandomInt;
/**
 * Decompress body based on content-encoding
 *
 * @param response
 */
const DecompressBody = (response) => {
    if (!response.body) {
        return response.body;
    }
    const contentEncoding = response.getHeader('content-encoding');
    let body = response.body;
    switch (contentEncoding) {
        case 'gzip':
            body = zlib_1.unzipSync(body);
            break;
        case 'br':
            body = zlib_1.brotliDecompressSync(body);
            break;
        case 'deflate':
            body = zlib_1.inflateSync(body);
            break;
        default:
            break;
    }
    return body.toString('utf-8');
};
exports.DecompressBody = DecompressBody;
/**
 * Create a Transaction object from express req/res.
 * To be used after the response closes
 *
 * @param request
 * @param response
 */
const CreateTransaction = (request, response) => ({
    request: {
        method: request.method,
        urlPath: new url_1.URL(request.originalUrl, 'http://localhost/').pathname,
        route: request.route ? request.route.path : null,
        params: request.params
            ? Object.keys(request.params).map((paramName) => ({
                name: paramName,
                value: request.params[paramName]
            }))
            : [],
        queryParams: request.query
            ? Object.keys(request.query).map((queryParamName) => ({
                name: queryParamName,
                value: request.query[queryParamName]
            }))
            : [],
        body: request.body,
        headers: TransformHeaders(request.headers).sort(AscSort)
    },
    response: {
        statusCode: response.statusCode,
        headers: TransformHeaders(response.getHeaders()).sort(AscSort),
        body: exports.DecompressBody(response)
    },
    routeResponseUUID: response.routeResponseUUID,
    routeUUID: response.routeUUID,
    proxied: request.proxied || false
});
exports.CreateTransaction = CreateTransaction;
/**
 * Convert a string to base64
 *
 * @param text
 */
const ToBase64 = (text) => {
    if (typeof btoa === 'function') {
        return btoa(text);
    }
    if (typeof Buffer === 'function') {
        return Buffer.from(text).toString('base64');
    }
    return text;
};
exports.ToBase64 = ToBase64;
/**
 * Convert a SafeString to a string if needed.
 *
 * @param text
 * @returns
 */
const fromSafeString = (text) => text instanceof handlebars_1.SafeString ? text.toString() : text;
exports.fromSafeString = fromSafeString;
//# sourceMappingURL=utils.js.map